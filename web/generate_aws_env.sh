#!/usr/bin/env bash

# Generate a environment file from retrieving AWS secrets

# Variables
AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-"us-west-2"}
ENV_FILE=${ENV_FILE:-".env"}
SECRETS_YAML=${SECRETS_YAML:-".env.secrets.yaml"}

# Functions

## Check for required tools
check_requirements() {
    if ! command -v aws ; then
        echo "aws not found!"
        exit 1
    fi

    if ! command -v jq ; then
        echo "jq not found!"
        exit 1
    fi

    if ! command -v yq ; then
        echo "yq not found!"
        exit 1
    fi
}

## Retrieve Secret Values
get_secret_values() {
    local secret_name="$1"
    echo "# Secret: $secret_name\n"

    local secret_string
    secret_string=$(aws secretsmanager get-secret-value \
        --secret-id $secret_name \
        --region "$AWS_DEFAULT_REGION" \
        --query SecretString \
        --output text 2>/dev/null)

    if [ -z "$secret_string" ]; then
        echo "Error: Could not retrieve secret '$secret_name'. Check permissions and secret existence." >&2
        return 1
    fi

    # Use jq to parse the SecretString (which is a JSON string)
    # and iterate over its key-value pairs.
    echo "$secret_string" | jq -r 'to_entries[] | "\(.key)=\(.value)"'
    return 0
}

## Create the environment file
generate_env_file() {
    echo "# Generated by $(basename "$0") on $(date)" > "$ENV_FILE"
    echo "" >> "$ENV_FILE"

    # Get top-level keys (secret names) from the YAML file
    secret_names=$(yq -r 'keys | .[]' "$SECRETS_YAML")

    # Loop through each secret name found in the YAML
    while IFS= read -r secret_name; do
        # Skip empty lines that yq might output
        if [ -z "$secret_name" ]; then
            continue
        fi

        echo "Processing keys for secret: $secret_name"

        # Fetch values from AWS Secrets Manager and append to .env
        if ! get_secret_values "$secret_name" >> "$ENV_FILE"; then
            echo "Failed to process secret: $secret_name. Aborting."
            rm -f "$ENV_FILE" # Clean up the partially created file
            exit 1
        fi

        echo "" >> "$ENV_FILE"
    done <<< "$secret_names"

    echo "Successfully generated $ENV_FILE"
}

## Display usage
usage()
{
  echo "Usage: [Environment Variables] generate_aws_env.sh [options]"
  echo "  Environment Variables:"
  echo "    AWS_DEFAULT_REGION                         set the AWS region to search (default: us-west-2)"
  echo "    ENV                                        set the environment file to use (default: .env)"
  echo "    SECRETS_YAML                               set the template file to use (default: .env.secrets.yaml)"
  echo "  Options:"
  echo "    -e | --env                                 set the environment file to use (overrides environment variable)"
  echo "    -h | --help                                display this usage information"
  echo "    -r | --region                              set the AWS region to search (overrides environment variable)"
  echo "    -t | --template                            template file to use (overrides environment variable)"
}

# Logic

POSITIONAL_ARGS=()

while [[ $# -gt 0 ]]; do
  case $1 in
    -r|--region)
      AWS_DEFAULT_REGION="$2"
      shift # past argument
      shift # past value
      ;;
    -e|--env)
      ENV="$2"
      shift # past argument
      shift # past value
      ;;
    -t|--template)
      SECRETS_YAML="$2"
      shift # past argument
      shift # past value
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    -*|--*)
      echo "Unknown option $1"
      exit 1
      ;;
    *)
      POSITIONAL_ARGS+=("$1") # save positional arg
      shift # past argument
      ;;
  esac
done

set -- "${POSITIONAL_ARGS[@]}" # restore positional parameters

check_requirements
generate_env_file